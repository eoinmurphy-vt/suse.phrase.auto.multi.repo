= Asignación a clusters descendentes
:revdate: 2025-04-30
:page-revdate: {revdate}

ifeval::["{product}" == "fleet"]
https://ranchermanager.docs.rancher.com/integrations-in-rancher/fleet[{product_name} en Rancher] permite a los usuarios gestionar clústeres fácilmente como si fueran un único clúster. Los usuarios pueden desplegar paquetes, que pueden estar formados por manifiestos de despliegue o cualquier otro recurso de Kubernetes, a través de clústeres mediante la configuración de agrupación.

endif::[]

ifeval::["{product}" == "continuous-delivery"]
https://documentation.suse.com/cloudnative/rancher-manager/latest/en/integrations/fleet/overview.html[{product_name} en Rancher] permite a los usuarios gestionar clústeres fácilmente como si fueran un único clúster. Los usuarios pueden desplegar paquetes, que pueden estar formados por manifiestos de despliegue o cualquier otro recurso de Kubernetes, a través de clústeres mediante la configuración de agrupación.
endif::[]
[IMPORTANT]
====

*Sólo multicluster*:
Este enfoque sólo se aplica si está ejecutando {product_name} en un estilo de clúster múltiple. Si no se especifican objetivos, es decir, cuando se utiliza un clúster único, los paquetes se dirigen al grupo de clústeres predeterminado.
====


Cuando se despliega `GitRepos` en clústeres descendentes, los clústeres deben asignarse a un objetivo.

== Definición de objetivos

Los objetivos de despliegue de `GitRepo` se realiza utilizando el campo `spec.targets` para hacer coincidir clusters o grupos de clusters. La especificación YAML es la siguiente.

[,yaml]
----
kind: GitRepo
apiVersion: fleet.cattle.io/v1alpha1
metadata:
  name: myrepo
  namespace: clusters
spec:
  repo: https://github.com/rancher/fleet-examples
  paths:
  - simple

  # Targets are evaluated in order and the first one to match is used. If
  # no targets match then the evaluated cluster will not be deployed to.
  targets:
  # The name of target. This value is largely for display and logging.
  # If not specified a default name of the format "target000" will be used
  - name: prod
    # A selector used to match clusters.  The structure is the standard
    # metav1.LabelSelector format. If clusterGroupSelector or clusterGroup is specified,
    # clusterSelector will be used only to further refine the selection after
    # clusterGroupSelector and clusterGroup is evaluated.
    clusterSelector:
      matchLabels:
        env: prod
    # A selector used to match cluster groups.
    clusterGroupSelector:
      matchLabels:
        region: us-east
    # A specific clusterGroup by name that will be selected
    clusterGroup: group1
    # A specific cluster by name that will be selected
    clusterName: cluster1
----

== Coincidencia de objetivos

Todos los clústeres y grupos de clústeres del mismo espacio de nombres que `GitRepo` se evaluarán con respecto a todos los objetivos.
Si alguno de los objetivos coincide con el clúster, entonces `GitRepo` se desplegará en el clúster descendente. Si no se produce ninguna coincidencia, `GitRepo` no se desplegará en ese clúster.

Existen tres enfoques para emparejar agrupaciones.
Se pueden utilizar selectores de clústeres, selectores de grupos de clústeres o un nombre explícito de grupo de clústeres.  Todos los criterios son aditivos, por lo que la coincidencia final se evalúa como "clusterSelector && clusterGroupSelector && clusterGroup".  Si alguno de los tres tiene el valor por defecto, se elimina de los criterios.  El valor por defecto es null o "".  Es importante darse cuenta de que el valor `{}` para un selector significa "coincide con todo".

[,yaml]
----
targets:
  # Match everything
  - clusterSelector: {}
  # Selector ignored
  - clusterSelector: null
----

También puedes buscar clusters por su nombre:

[,yaml]
----
targets:
  - clusterName: fleetname
----

Cuando utilice {product_name} en Rancher, asegúrese de poner el nombre del recurso `clusters.fleet.cattle.io`.

== Objetivo por defecto

Si no se establece ningún objetivo para `GitRepo`, se aplicará el valor de los objetivos por defecto.  El valor por defecto de los objetivos es el siguiente.

[,yaml]
----
targets:
- name: default
  clusterGroup: default
----

Esto significa que si deseas configurar una ubicación por defecto a la que irán los GitRepos no configurados, entonces simplemente crea un grupo de clusters llamado default y añade clusters a él.

== Personalización por clúster

[IMPORTANT]
====

El `targets:` en el recurso `GitRepo` selecciona los clusters en los que desplegar. `targetCustomizations:` en `fleet.yaml` sólo anula los valores del timón y no cambia la orientación.
====


Para demostrar cómo desplegar manifiestos Kubernetes a través de diferentes clusters con personalización utilizando {product_name}, utilizaremos https://github.com/rancher/fleet-examples/blob/master/multi-cluster/helm/fleet.yaml[multi-cluster/helm/fleet.yaml].

*Situación:* El usuario tiene tres clusters con tres etiquetas diferentes: `env=dev`, `env=test`, y `env=prod`. El usuario quiere desplegar una aplicación frontend con una base de datos backend a través de estos clusters.

*Comportamiento esperado:*

* Tras el despliegue en el clúster `dev`, la replicación de la base de datos no está activada.
* Tras el despliegue en el clúster `test`, se activa la replicación de la base de datos.
* Tras el despliegue en el clúster `prod`, se habilita la replicación de bases de datos y se exponen los servicios del equilibrador de carga.

*Ventajas de {product_name}:*

En lugar de desplegar la aplicación en cada clúster, {product_name} permite desplegarla en todos los clústeres siguiendo estos pasos:

. Despliegue gitRepo `https://github.com/rancher/fleet-examples.git` y especifique la ruta `multi-cluster/helm`.
. En `multi-cluster/helm`, un gráfico Helm desplegará el servicio de aplicación frontend y el servicio de base de datos backend.
. La siguiente regla se definirá en `fleet.yaml`:

----
targetCustomizations:
- name: dev
  helm:
    values:
      replication: false
  clusterSelector:
    matchLabels:
      env: dev

- name: test
  helm:
    values:
      replicas: 3
  clusterSelector:
    matchLabels:
      env: test

- name: prod
  helm:
    values:
      serviceType: LoadBalancer
      replicas: 3
  clusterSelector:
    matchLabels:
      env: prod
----

*Resultado:*

{product_name} desplegará el gráfico Helm con su `values.yaml` personalizado a los diferentes clusters.

NOTE: La gestión de la configuración no se limita a los despliegues, sino que puede ampliarse a la gestión de la configuración general. {product_name} es capaz de aplicar la gestión de la configuración a través de la personalización entre cualquier conjunto de clústeres de forma automática.

=== Personalizaciones admitidas

* xref:reference/ref-crds.adoc#_bundledeploymentoptions[DefaultNamespace]
* xref:reference/ref-crds.adoc#_bundledeploymentoptions[ForceSyncGeneration]
* xref:reference/ref-crds.adoc#_bundledeploymentoptions[MantenerRecursos]
* xref:reference/ref-crds.adoc#_bundledeploymentoptions[ServiceAccount]
* xref:reference/ref-crds.adoc#_bundledeploymentoptions[TargetNamespace]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.Atomic]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.Chart]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.DisablePreProcess]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.Force]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.ReleaseName]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.Repo]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.TakeOwnership]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.TimeoutSeconds]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.ValuesFrom]
* xref:reference/ref-crds.adoc#_helmoptions[Timón.Valores]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.Version]
+

[CAUTION]
.información importante
====
Anular la versión de un gráfico Helm a través de personalizaciones de destino dará lugar a paquetes que contienen _todas las_ versiones, es decir, la predeterminada y la(s) personalizada(s), del gráfico, para acomodar todos los clusters. Esto a su vez significa que {product_name} desplegará paquetes más grandes.
+
Dado que {product_name} almacena los paquetes a través de etcd, esto puede causar problemas en algunos clústeres en los que el tamaño de los paquetes resultantes puede superar el tamaño máximo de blob configurado en etcd. Para más información, consulte https://github.com/rancher/fleet/issues/1650[].
====


* xref:reference/ref-crds.adoc#_helmoptions[Helm.WaitForJobs]
* xref:reference/ref-crds.adoc#_kustomizeoptions[Personalizar.Dir]
* xref:reference/ref-crds.adoc#_yamloptions[YAML.Overlays]
* xref:reference/ref-crds.adoc#_diffoptions[Diff.ComparePatches]

== Ejemplos adicionales

Los ejemplos que utilizan Kubernetes YAML sin procesar, gráficos Helm, Kustomize y combinaciones de los tres se encuentran en el https://github.com/rancher/fleet-examples/[repositorio].
