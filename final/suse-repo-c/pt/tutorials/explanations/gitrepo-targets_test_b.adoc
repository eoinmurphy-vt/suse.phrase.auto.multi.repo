= Mapeamento para clusters downstream
:revdate: 2025-04-30
:page-revdate: {revdate}

ifeval::["{product}" == "fleet"]
https://ranchermanager.docs.rancher.com/integrations-in-rancher/fleet[{product_name} no Rancher] permite que os usuários gerenciem clusters facilmente como se fossem um único cluster. Os usuários podem implantar pacotes, que podem ser compostos por manifestos de implantação ou qualquer outro recurso do Kubernetes, em clusters usando a configuração de agrupamento.

endif::[]

ifeval::["{product}" == "continuous-delivery"]
https://documentation.suse.com/cloudnative/rancher-manager/latest/en/integrations/fleet/overview.html[{product_name} no Rancher] permite que os usuários gerenciem clusters facilmente como se fossem um único cluster. Os usuários podem implantar pacotes, que podem ser compostos por manifestos de implantação ou qualquer outro recurso do Kubernetes, em clusters usando a configuração de agrupamento.
endif::[]
[IMPORTANT]
====

*Somente para vários clusters*:
Essa abordagem só se aplica se você estiver executando o {product_name} em um estilo de vários clusters. Se nenhum destino for especificado, ou seja, ao usar um único cluster, os pacotes terão como destino o grupo de clusters padrão.
====


Ao implementar o `GitRepos` em clusters downstream, os clusters devem ser mapeados para um destino.

== Definição de metas

Os alvos de implementação do `GitRepo` são feitos usando o campo `spec.targets` para corresponder a clusters ou grupos de clusters. A especificação YAML é a seguinte.

[,yaml]
----
kind: GitRepo
apiVersion: fleet.cattle.io/v1alpha1
metadata:
  name: myrepo
  namespace: clusters
spec:
  repo: https://github.com/rancher/fleet-examples
  paths:
  - simple

  # Targets are evaluated in order and the first one to match is used. If
  # no targets match then the evaluated cluster will not be deployed to.
  targets:
  # The name of target. This value is largely for display and logging.
  # If not specified a default name of the format "target000" will be used
  - name: prod
    # A selector used to match clusters.  The structure is the standard
    # metav1.LabelSelector format. If clusterGroupSelector or clusterGroup is specified,
    # clusterSelector will be used only to further refine the selection after
    # clusterGroupSelector and clusterGroup is evaluated.
    clusterSelector:
      matchLabels:
        env: prod
    # A selector used to match cluster groups.
    clusterGroupSelector:
      matchLabels:
        region: us-east
    # A specific clusterGroup by name that will be selected
    clusterGroup: group1
    # A specific cluster by name that will be selected
    clusterName: cluster1
----

== Correspondência de alvos

Todos os clusters e grupos de clusters no mesmo namespace que o `GitRepo` serão avaliados em relação a todos os alvos.
Se algum dos destinos corresponder ao cluster, o `GitRepo` será implantado no cluster downstream. Se não houver correspondência, o `GitRepo` não será implantado nesse cluster.

Há três abordagens para a correspondência de clusters.
É possível usar seletores de cluster, seletores de grupo de cluster ou um nome explícito de grupo de cluster.  Todos os critérios são aditivos, de modo que a correspondência final é avaliada como "clusterSelector && clusterGroupSelector && clusterGroup".  Se qualquer um dos três tiver o valor padrão, ele será excluído dos critérios.  O valor padrão é nulo ou "".  É importante perceber que o valor `{}` para um seletor significa "corresponder a tudo".

[,yaml]
----
targets:
  # Match everything
  - clusterSelector: {}
  # Selector ignored
  - clusterSelector: null
----

Você também pode fazer a correspondência de clusters por nome:

[,yaml]
----
targets:
  - clusterName: fleetname
----

Ao usar {product_name} no Rancher, certifique-se de colocar o nome do recurso `clusters.fleet.cattle.io`.

== Alvo padrão

Se nenhum alvo for definido para o site `GitRepo`, o valor padrão dos alvos será aplicado.  O valor padrão dos alvos é o seguinte.

[,yaml]
----
targets:
- name: default
  clusterGroup: default
----

Isso significa que, se você quiser definir um local padrão para o qual os GitRepos não configurados irão, basta criar um grupo de clusters chamado default e adicionar clusters a ele.

== Personalização por cluster

[IMPORTANT]
====

O site `targets:` no recurso `GitRepo` seleciona clusters para implantação. O endereço `targetCustomizations:` em `fleet.yaml` substitui apenas os valores do Helm e não altera a mira.
====


Para demonstrar como implantar manifestos do Kubernetes em diferentes clusters com personalização usando {product_name}, usaremos https://github.com/rancher/fleet-examples/blob/master/multi-cluster/helm/fleet.yaml[multi-cluster/helm/fleet.yaml].

*Situação:* O usuário tem três clusters com três rótulos diferentes: `env=dev`, `env=test`, e `env=prod`. O usuário deseja implementar um aplicativo de front-end com um banco de dados de back-end nesses clusters.

*Comportamento esperado:*

* Após a implementação no cluster `dev`, a replicação do banco de dados não é ativada.
* Após a implementação no cluster `test`, a replicação do banco de dados é ativada.
* Após a implementação no cluster `prod`, a replicação do banco de dados é ativada e os serviços do balanceador de carga são expostos.

*Vantagem do site {product_name}:*

Em vez de implantar o aplicativo em cada cluster, o site {product_name} permite que você implante em todos os clusters seguindo estas etapas:

. Implante o gitRepo `https://github.com/rancher/fleet-examples.git` e especifique o caminho `multi-cluster/helm`.
. Em `multi-cluster/helm`, um gráfico do Helm implantará o serviço de aplicativo de front-end e o serviço de banco de dados de back-end.
. A regra a seguir será definida em `fleet.yaml`:

----
targetCustomizations:
- name: dev
  helm:
    values:
      replication: false
  clusterSelector:
    matchLabels:
      env: dev

- name: test
  helm:
    values:
      replicas: 3
  clusterSelector:
    matchLabels:
      env: test

- name: prod
  helm:
    values:
      serviceType: LoadBalancer
      replicas: 3
  clusterSelector:
    matchLabels:
      env: prod
----

*Resultado:*

{product_name} implantará o gráfico do Helm com seu `values.yaml` personalizado nos diferentes clusters.

NOTE: O gerenciamento de configuração não se limita às implementações, mas pode ser expandido para o gerenciamento geral de configuração. O site {product_name} é capaz de aplicar o gerenciamento de configuração por meio da personalização entre qualquer conjunto de clusters automaticamente.

=== Personalizações suportadas

* xref:reference/ref-crds.adoc#_bundledeploymentoptions[DefaultNamespace]
* xref:reference/ref-crds.adoc#_bundledeploymentoptions[ForceSyncGeneration]
* xref:reference/ref-crds.adoc#_bundledeploymentoptions[KeepResources]
* xref:reference/ref-crds.adoc#_bundledeploymentoptions[Conta de serviço]
* xref:reference/ref-crds.adoc#_bundledeploymentoptions[TargetNamespace]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.Atomic]
* xref:reference/ref-crds.adoc#_helmoptions[Leme.Chart]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.DisablePreProcess]
* xref:reference/ref-crds.adoc#_helmoptions[Força do leme]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.ReleaseName]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.Repo]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.TakeOwnership]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.TimeoutSeconds]
* xref:reference/ref-crds.adoc#_helmoptions[Helm.ValuesFrom]
* xref:reference/ref-crds.adoc#_helmoptions[Valores do leme]
* xref:reference/ref-crds.adoc#_helmoptions[Versão do leme]
+

[CAUTION]
.Informações importantes
====
Substituir a versão de um gráfico do Helm por meio de personalizações de destino resultará em pacotes contendo _todas as_ versões, ou seja, a padrão e a(s) personalizada(s), do gráfico, para acomodar todos os clusters. Isso, por sua vez, significa que o site {product_name} implementará pacotes maiores.
+
Como o {product_name} armazena pacotes por meio do etcd, isso pode causar problemas em alguns clusters nos quais os tamanhos dos pacotes resultantes podem exceder o tamanho máximo de blob configurado do etcd. Consulte https://github.com/rancher/fleet/issues/1650[nesta edição] para obter mais detalhes.
====


* xref:reference/ref-crds.adoc#_helmoptions[Helm.WaitForJobs]
* xref:reference/ref-crds.adoc#_kustomizeoptions[Kustomize.Dir]
* xref:reference/ref-crds.adoc#_yamloptions[YAML.Overlays]
* xref:reference/ref-crds.adoc#_diffoptions[Diff.ComparePatches]

== Exemplos adicionais

Exemplos usando Kubernetes YAML bruto, gráficos Helm, Kustomize e combinações dos três estão no https://github.com/rancher/fleet-examples/[repositório].
